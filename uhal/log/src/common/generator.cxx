/*
---------------------------------------------------------------------------

    This file is part of uHAL.

    uHAL is a hardware access library and programming framework
    originally developed for upgrades of the Level-1 trigger of the CMS
    experiment at CERN.

    uHAL is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    uHAL is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with uHAL.  If not, see <http://www.gnu.org/licenses/>.


      Andrew Rose, Imperial College, London
      email: awr01 <AT> imperial.ac.uk

      Marc Magrans de Abril, CERN
      email: marc.magrans.de.abril <AT> cern.ch

---------------------------------------------------------------------------
*/


#include <cctype>
#include <exception>
#include <fstream>
#include <iostream>
#include <stdint.h>
#include <stdlib.h>
#include <sstream>
#include <string>
#include <vector>

#include <boost/algorithm/string/case_conv.hpp>


static const std::string gLogLevelsChar[] = { "Fatal" , "Error" , "Warning" , "Notice" , "Info" , "Debug" };
static const uint32_t gNumberEntries ( 6 );

static const std::string gDefaultLevel ( "Info" );

static const std::vector< std::string > gLogLevels ( gLogLevelsChar , gLogLevelsChar+gNumberEntries );



std::string gDivider (	"// " + std::string ( 150,'=' ) + "\n" +
                        "// WARNING! This file is automatically generated! Do not modify it! Any changes will be overwritten!\n" +
                        "// " + std::string ( 150,'=' ) + "\n" );



void fileHeaders ( std::ofstream& aHppFile , std::ofstream& aHxxFile , std::ofstream& aCppFile )
{
  aHppFile	<< "\n"
            << "#ifndef _uhal_log_log_hpp_\n"
            << "#define _uhal_log_log_hpp_\n"
            << "\n\n"
            << "#include <iosfwd>  // for ostream\n"
            << "#include <mutex>   // for lock_guard, mutex\n"
            << "\n"
            << "#include <uhal/log/log_inserters.hpp>\n"
            << "#include <uhal/log/LogLevels.hpp>\n"
            << "#include <uhal/log/exception.hpp>\n"
            << "\n"
            << "\n"
            << "namespace uhal{\n"
            << "\n"
            << "class DebugLevel;\n"
            << "class InfoLevel;\n"
            << "class NoticeLevel;\n"
            << "class WarningLevel;\n"
            << "class ErrorLevel;\n"
            << "class FatalLevel;\n"
            << "\n"
            << gDivider
            << "\n";
  aHxxFile	<< "\n"
            << "#include <mutex>                           // for lock_guard, mutex\n"
            << "#include <sstream>                         // for ostream, stringstream, endl\n"
            << "#include <string>                          // for operator+, basic_string\n"
            << "\n"
            << "#include \"uhal/log/exception.hpp\"          // for exception\n"
            << "#include \"uhal/log/LogLevels.hpp\"          // for insert, ErrorLevel, DebugL...\n"
            << "#include \"uhal/log/log_inserters.quote.hpp\"  // for operator<<\n"
            << "\n\n"
            << "namespace uhal{\n"
            << "\n"
            << gDivider
            << "\n";
  aCppFile	<< "\n"
            << "#include <mutex>                             // for lock_guard, mutex\n"
            << "#include <stdlib.h>                          // for getenv\n"
            << "\n"
            << "#include \"uhal/log/LogLevels.hpp\"            // for BaseLogLevel, Info, Info...\n"
            << "#include \"uhal/log/log.hpp\"                  // for log\n"
            << "#include \"uhal/log/log_inserters.quote.hpp\"  // for operator<<, Quote\n"
            << "\n\n"
            << "namespace uhal{\n"
            << "\n"
            << gDivider
            << "\n";
}


void log_configuration_functions ( std::ofstream& aHppFile , std::ofstream& aHxxFile , std::ofstream& aCppFile )
{
  aHppFile << "/**\n"
           << "\tFunction to specify that the logging level should be retrieved from an environment variable\n"
           << "\t@param aEnvVar the name of the environment variable which is used to specify the logging level\n"
           << "*/\n"
           << "void setLogLevelFromEnvironment ( const char* aEnvVar );\n";
  aCppFile << "void setLogLevelFromEnvironment ( const char* aEnvVar )\n"
           << "{\n"
           << "\tchar * lEnvVar = getenv ( aEnvVar );\n"
           << "\tif( !lEnvVar )\n"
           << "\t{\n"
           //           << "\t\t\n"
           << "\t\tlog( Warning() , \"No environment variable \" , Quote( aEnvVar ) , \" set. Using level \" , Quote( \"Info\" ) , \" instead.\" );\n"
           << "\t\tsetLogLevelTo ( " << gDefaultLevel << "() );\n"
           << "\t\treturn;\n"
           << "\t}\n"
           << "\n"
           << "\t//Just comparing the first letter of the environment variable for speed!!!\n"
           << "\tswitch ( lEnvVar[0] )\n"
           << "\t{\n";

  for ( const auto& lLevel: gLogLevels )
  {
    aCppFile << "\t\tcase '" << char ( std::tolower ( lLevel.at ( 0 ) ) ) << "' :\n"
             << "\t\tcase '" << char ( std::toupper ( lLevel.at ( 0 ) ) ) << "' :\n"
             << "\t\t\tsetLogLevelTo ( " << lLevel << "() );\n"
             << "\t\t\tbreak;\n";
  }

  aCppFile << "\t\tdefault:\n"
           << "\t\t\t\n"
           << "\t\t\tlog ( Warning() , \"Environment varible has invalid value \" , Quote( lEnvVar ) , \". Using level \" , Quote ( \"Info\" ) , \" instead.\" );\n"
           << "\t\t\tsetLogLevelTo ( Info() );\n"
           << "\t}\n"
           << "}\n"
           << "\n";
  aCppFile	<< gDivider
            << "\n";
  // -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  aHppFile << "/**\n"
           << "\tFunction to disable all logging levels\n"
           << "*/\n"
           << "void disableLogging();\n";
  aCppFile << "void disableLogging()\n"
           << "{\n";

  for ( const auto& lLevel: gLogLevels )
  {
    aCppFile << "\tlog_configuration::mLoggingIncludes" << lLevel << " = false;\n";
  }

  aCppFile << "}\n"
           << "\n";
  aCppFile	<< gDivider
            << "\n";
  // -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  aHppFile << "/**\n"
           << "\tFunction to retrieve the mutex lock used by the logger\n"
           << "*/\n"
           << "std::mutex& GetLoggingMutex();\n";
  aCppFile << "std::mutex& GetLoggingMutex()\n"
           << "{\n"
           << "\treturn log_configuration::mMutex;\n"
           << "}\n"
           << "\n"
           << gDivider
           << "\n";
  // -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  std::stringstream lIfDefs, lIfDefs2, lEndIfs;

  for ( std::vector< std::string >::const_iterator lIt = gLogLevels.begin() ; lIt != gLogLevels.end() ; ++lIt )
  {
    lIfDefs << "\t#ifndef LOGGING_EXCLUDE_" << boost::to_upper_copy ( *lIt ) << "\n";
    lIfDefs2 << "\t#ifndef LOGGING_EXCLUDE_" << boost::to_upper_copy ( *lIt ) << " // A waste of time to change any level below this if it is going to disabled by compile-time checking anyway... \n"
             << "\t\tlog_configuration::mLoggingIncludes" << *lIt << " = true;\n";
    lEndIfs << "\t#endif\n";
    //     aHppFile << "//! Helper struct representing the " << *lIt << " log level to allow us to specialize functions according to their log level\n"
    //              << "class " << *lIt << "Level : public BaseLogLevel\n"
    //              << "\t{\n"
    //              << "\t\tpublic:\n"
    //              << "\t\t\t"<< *lIt << "Level( std::ostream& aStr ) : BaseLogLevel( aStr ){}\n"
    //              << "\t\t\t"<< *lIt << "Level& operator() (){ return *this; }\n"
    //              << "\t};\n"
    //              << "\n"
    //              << *lIt << "Level " << *lIt << "( std::cout );\n";
    aHppFile << "/**\n"
             << "\tFunction to specify, at runtime, that only messages with a severity level above " << *lIt << " should be logged\n"
             << "*/\n"
             << "void setLogLevelTo ( const " << *lIt << "Level& /**< a dummy parameter to choose the specialization of the function for the " << *lIt << " level */ );\n";
    aCppFile << "void setLogLevelTo ( const " << *lIt << "Level& )\n"
             << "{\n"
             << lIfDefs2.str();

    for ( std::vector< std::string >::const_iterator lIt2 = lIt+1 ; lIt2 != gLogLevels.end() ; ++lIt2 )
    {
      aCppFile << "\t\tlog_configuration::mLoggingIncludes" << *lIt2 << " = false;\n";
    }

    aCppFile << lEndIfs.str()
             << "}\n"
             << "\n";
    aHppFile << "/**\n"
             << "\tFunction to check at runtime whether the level " << *lIt << " is to be included in the log output\n"
             << "\t@return whether the level " << *lIt << " is to be included in the log output\n"
             << "*/\n"
             << "const bool& LoggingIncludes ( const " << *lIt << "Level& /**< a dummy parameter to choose the specialization of the function for the " << *lIt << " level */ );\n"
             << "\n";
    aCppFile << "const bool& LoggingIncludes ( const " << *lIt << "Level& )\n"
             << "{\n"
             << lIfDefs.str()
             << "\t\treturn log_configuration::mLoggingIncludes" << *lIt << ";\n"
             << lEndIfs.str()
             << "\treturn log_configuration::mFalse;\n"
             << "}\n"
             << "\n";
  }

  aHppFile << "//! Class to restrict access to the log configuration parameters\n"
           << "class log_configuration\n"
           << "{\n"
           << "\t//! Constructor\n"
           << "\tlog_configuration();\n"
           << "\t//! Destructor\n"
           << "\tvirtual ~log_configuration();\n"
           << "\n"
           << "\tfriend void disableLogging();\n"
           << "\n";
  bool lIncludeLevelByDefault ( true );

  for ( const auto& lLevel: gLogLevels )
  {
    aHppFile << "\t//! static bool storing whether the " << lLevel << " level is to be included in the log output\n"
             << "\tstatic bool mLoggingIncludes" << lLevel << ";\n";

    if ( lIncludeLevelByDefault )
    {
      aCppFile << "bool log_configuration::mLoggingIncludes" << lLevel << " = true; // No #ifdefs required here since they are implemented in all the access functions.\n";
    }
    else
    {
      aCppFile << "bool log_configuration::mLoggingIncludes" << lLevel << " = false; // No #ifdefs required here since they are implemented in all the access functions.\n";
    }

    if ( lLevel == gDefaultLevel )
    {
      lIncludeLevelByDefault = false;
    }

    aHppFile << "\t//!Make setLogLevelTo function a friend so it can access our private members\n"
             << "\tfriend void setLogLevelTo ( const " << lLevel << "Level& );\n"
             << "\t//!Make LoggingIncludes function a friend so it can access our private members\n"
             << "\tfriend const bool& LoggingIncludes ( const " << lLevel << "Level& );\n"
             << "\n";
  }

  aHppFile << "\t//!Define a static const member variable to have a value of true so that we can safely return a const reference to true\n"
           << "\tstatic const bool mTrue;\n"
           << "\t//!Define a static const member variable to have a value of false so that we can safely return a const reference to false\n"
           << "\tstatic const bool mFalse;\n"
           << "\n"
           << "\t//!Make GetLoggingMutex function a friend so it can access our private members\n"
           << "\tfriend std::mutex& GetLoggingMutex();\n"
           << "\t//!Define a static Mutex lock for thread safe logging\n"
           << "\tstatic std::mutex mMutex;\n"
           << "};\n"
           << "\n";
  aCppFile << "\n"
           << "const bool log_configuration::mTrue = true;\n"
           << "const bool log_configuration::mFalse = false;\n"
           << "\n"
           << "std::mutex log_configuration::mMutex;\n"
           << "\n";
  aHppFile	<< gDivider
            << "\n";
  aCppFile	<< gDivider
            << "\n";
}


std::string suffix ( uint32_t i )
{
  i = i % 100;

  if ( i > 10 && i < 20 )
  {
    return "th";
  }

  std::string lIndices[] = { "th" , "st" , "nd" , "rd" , "th" , "th" , "th" , "th" , "th" , "th" };
  return lIndices[ i%10 ];
}


void log_functions ( std::ofstream& aHppFile , std::ofstream& aHxxFile , std::ofstream& aCppFile )
{
  std::stringstream lIfDefs , lEndIfs;

  for ( const auto& lLevel: gLogLevels )
  {
    lIfDefs << "\t#ifndef LOGGING_EXCLUDE_" << boost::to_upper_copy ( lLevel ) << "\n";
    lEndIfs << "\t#endif\n";
    std::stringstream lTemplates;
    std::stringstream lArgs;
    std::stringstream lInstructions;
    std::stringstream lDoxygen;
    lDoxygen << "\t\tFunction to add a log entry at " << lLevel << " level\n"
             << "\t\t@param a" << lLevel << " a dummy parameter to choose the specialization of the function for the " << lLevel << " level\n";

    for ( uint32_t i = 0 ; i!=MAX_NUM_ARGS ; ++i )
    {
      lTemplates << " typename T" << i << " ,";
      std::string lTemplatesStr ( lTemplates.str() );
      lTemplatesStr.resize ( lTemplatesStr.size()-1 );
      lArgs << " const T" << i << "& aArg" << i << " ,";
      std::string lArgsStr ( lArgs.str() );
      lArgsStr.resize ( lArgsStr.size()-1 );
      lInstructions << "\t\t\tinsert( lStr , aArg" << i << " );\n";
      lDoxygen << "\t\t@param aArg" << i << " a templated argument to be added to the log " << ( i+1 ) << suffix ( i+1 ) <<"\n";
      aHppFile << "\t/**\n"
               << lDoxygen.str()
               << "\t*/\n"
               << "\ttemplate<" << lTemplatesStr << ">\n"
               //               << "\tvoid operator() ( const " <<lLevel << "& a" << lLevel << " ," << lArgsStr << ");\n"
               << "\tvoid log ( " <<lLevel << "Level& a" << lLevel << " ," << lArgsStr << ");\n"
               << "\n";
      aHxxFile << "template<" << lTemplatesStr << ">\n"
               //               << "void logger::operator() ( const " <<lLevel << "& a" << lLevel << " ," << lArgsStr << " )\n"
               << "void log (  " <<lLevel << "Level& a" << lLevel << " ," << lArgsStr << " )\n"
               << "{\n"
               << lIfDefs.str()
               << "\t\tif( LoggingIncludes( a" << lLevel << " ) ){\n"
               << "\t\t\tstd::lock_guard<std::mutex> lLock ( GetLoggingMutex() );\n"
               << "\t\t\tstd::ostream& lStr( a" << lLevel << ".stream() );\n"
               << "\t\t\ta" << lLevel << ".head();\n"
               << lInstructions.str()
               << "\t\t\ta" << lLevel << ".tail();\n"
               << "\t\t}\n"
               << lEndIfs.str()
               << "}\n"
               << "\n";
    }

    aHppFile	<< gDivider
              << "\n";
    aHxxFile	<< gDivider
              << "\n";
  }

  {
    std::stringstream lTemplates;
    std::stringstream lArgs;
    std::stringstream lInstructions;
    std::stringstream lDoxygen;

    for ( uint32_t i = 0 ; i!=MAX_NUM_ARGS ; ++i )
    {
      lTemplates << " typename T" << i << " ,";
      std::string lTemplatesStr ( lTemplates.str() );
      lTemplatesStr.resize ( lTemplatesStr.size()-1 );
      lArgs << " const T" << i << "& aArg" << i << " ,";
      std::string lArgsStr ( lArgs.str() );
      lArgsStr.resize ( lArgsStr.size()-1 );
      lInstructions << "\t\t\tinsert( lStr , aArg" << i << " );\n";
      lDoxygen << "\t\t@param aArg" << i << " a templated argument to be added to the log " << ( i+1 ) << suffix ( i+1 ) <<"\n";
      aHppFile << "\t/**\n"
               << lDoxygen.str()
               << "\t*/\n"
               << "\ttemplate<" << lTemplatesStr << ">\n"
               //               << "\tvoid operator() ( const " <<*lIt << "& a" << *lIt << " ," << lArgsStr << ");\n"
               << "\tvoid log ( exception::exception& aExc ," << lArgsStr << ");\n"
               << "\n";
      aHxxFile << "template<" << lTemplatesStr << ">\n"
               //               << "void logger::operator() ( const " <<*lIt << "& a" << *lIt << " ," << lArgsStr << " )\n"
               << "void log (  exception::exception& aExc ," << lArgsStr << " )\n"
               << "{\n"
               << "\t\t\tstd::stringstream lStr;\n"
               << "\t\t\t{\n"
               << "\t\t\tstd::lock_guard<std::mutex> lLock ( GetLoggingMutex() );\n"
               << lInstructions.str()
               << "\t\t\taExc.append( ( lStr.str() + \"\\n\" ).c_str() );\n"
               << "\t\t\t}\n"
               << "\t\t\tlog ( Error() , lStr.str() );\n"
               << "}\n"
               << "\n";
    }

    aHppFile  << gDivider
              << "\n";
    aHxxFile  << gDivider
              << "\n";
  }
}


void fileFooters ( std::ofstream& aHppFile , std::ofstream& aHxxFile , std::ofstream& aCppFile )
{
  aHppFile	<< "}\n\n"
            << "#include \"uhal/log/log.hxx\"\n"
            << "#endif\n\n";
  aHxxFile	<< "}\n"
            << "\n";
  aCppFile	<< "}\n"
            << "\n";
}



int main ( int argc , char* argv[] )
{
  try
  {
    std::ofstream lHppFile ( "include/uhal/log/log.hpp" );

    if ( !lHppFile.is_open() )
    {
      std::cout << "Unable to open HPP file" << std::endl;
      return 1;
    }

    std::ofstream lHxxFile ( "include/uhal/log/log.hxx" );

    if ( !lHxxFile.is_open() )
    {
      std::cout << "Unable to open HXX file" << std::endl;
      return 1;
    }

    std::ofstream lCppFile ( "src/common/log.cpp" );

    if ( !lCppFile.is_open() )
    {
      std::cout << "Unable to open CPP file" << std::endl;
      return 1;
    }

    fileHeaders ( lHppFile , lHxxFile , lCppFile );
    log_configuration_functions ( lHppFile , lHxxFile , lCppFile );
    log_functions ( lHppFile , lHxxFile , lCppFile );
    fileFooters ( lHppFile , lHxxFile , lCppFile );
    lHppFile.close();
    lHxxFile.close();
    lCppFile.close();
  }
  catch ( const std::exception& aExc )
  {
    std::cerr << "ERROR: Caught exception : " << aExc.what() << std::endl;
    exit ( 1 );
  }
}


